tiered cubical blocks, each block being twice as large as it's composite blocks in each dimension, the smallest being a single uint3 point, representating a cubic lightyear.
star radius = 7*10^8m; smallest block side size = lightyear = 9*10^15m; so size of star is 10^-7 small blocks, centered in the block.
star should appear if the approximated cone belonging to a given pixel intersects that size. Cone slope is calculated on started based on resolution and FOV. Distant stars are allowed to briefly disappear due to errors in cone approximation, adding a twinkling effect. Obviously, if the cone includes the entire block, the star is also included. Rendering stops at the distance at which the cone includes the entirety of an order of block gauranteed to contain a star (calculated at startup based on cone angle).

phase 1: partial block. Starting at depth 0, ending on the depth where the cone slope is gauranteed to encompass an entire smallest order block (startup calculated qty), iterate on depth and decide if the star's cube intersects the pixel's cone.

phase 2: starting where phase1 stopped, ending on the depth when the cone is gauranteed to encompass a block gauranteed to contain a star, iterate on depth looking for enclosed blocks containing stars. (Iteration on block sizes may be necessary??)

phase 3: for the n-order block that's gauranteed to contain a star, find the stars

each time a star is found, increase the color by that star type's color, divided by the square of the distance



in 3d space
x * px = 0 defines a plane that parallels the yz identity plane
x * px + y * py = 0 defines a plane that does not parallel any axis plane
x * px + y * py + z * pz = 0 defines another plane
(x * px + y * py + z * pz) mod m = 0 defines an infinite series of parallel planes with a uniform gap between adjacents.
For any ray normal rn that does not parallel these planes, there exists a uniform distance rd between points of intersection with a plane
po = plane offset
((x - pox)*px + (x - poy)*py + (x - poz)*pz) mod m = 0

the lowest distance between planes would be along the normal orthagonal to the planes. Calculate that normal.
solve plane definition for z
-(x*px + y*py)/pz = z = f(x, y)
feed two orthagonal vectors through the translation to find their new z coords (no longer orthagonal, but also not colinear).
f(1, 0) = -px/pz
f(0, 1) = -py/pz
cross them:
[1, 0, -px/pz] × [0, 1, -py/pz] = [px/pz, py/pz, 1]
normalize:
pn = [px/pz, py/pz, 1] / len([px/pz, py/pz, 1])
pn = [px/pz, py/pz, 1] / sqrt(px^2/pz^2 + py^2/pz^2 + 1)
pd is distance between planes (along normal pn); m is modulus
x*px + y*py + z*pz = 0
(x + pd*pnx)*px + (y + pd*pny)*py + (z + pd*pnz)*pz = m
x*px + y*py + z*pz + pd*pnx*px + pd*pny*py + pd*pnz*pz = m
pd*pnx*px + pd*pny*py + pd*pnz*pz = m
pd*(pnx*px + pny*py + pnz*pz) = m
pd = m/(pnx*px + pny*py + pnz*pz)

now find distance along rn between adjacent planes (rd), by reverse-projection:
|      |
*      |
|\     |
| \rn* |
|  \rd |
|   \  |
|    \ |
|     \|
*------* angle t
| pd*pn|
|      |
|      |  cos(t) = (pn dot rn)
|      |  rd = pd / (pn dot rn)

now that we have rd, we need the next point on this ray (starting from ray origin ro) that contains a point of intersection with a plane that also lays on an integer coordinate
ro is NOT on a plane
ro IS on an integer coordinate (for now)

project ro along rn (possibly backwards) onto plane 0, call the new point rp, and the distance from ro along rn to rp is rol:
(x - pox)*px + (y - poy)*py + (z - poz)*pz = 0
dot(xyz - po, p) = 0
dot(rp - po, p) = 0
rp = rol*rn + ro
dot(rol*rn + ro - po, p) = 0
dot(rol*rn, p) + dot(ro, p) - dot(po, p) = 0
rol = (dot(po, p) - dot(ro, p)) / dot(rn, p)

Distance to next plane is rol positive-mod rd






not every plane struck by rn will be struck on integer coordinates. Only those that do get a star. First find the distance between adjacent intersections between planes and axis-aligned integer grid points. The origin (o) is always one point of intersection. Find the next along rn, it's length is rm.
rm is a multiple of rd and is an integer.
max_range is the furthest star we want to see (to avoid float precision issues with very distant stars)
TODO


now we just need to know how far into that repeating pattern the ray origin (ro) is.
translate ro parallel to the series of planes, to be on the line passing through the origin along rn, it's new length modulo rm (rx) is the portion of rm that is behind ro.
a = rx * rn
ax = rx*rnx
ay = rx*rny
az = rx*rnz
ax*px + ay*py + az*pz = rox*px + roy*py + roz*pz
rx*rnx*px + rx*rny*py + rx*rnz*pz = rox*px + roy*py + roz*pz
rx*(rnx*px + rny*py + rnz*pz) = rox*px + roy*py + roz*pz
rx = ((ro dot p) / (rn dot p)) mod rm






unused bits:

find distance between parallel planes:
x * px + y * py + z * pz = 0
x * px + (y + oy) * py + z * pz = m
x * px + z * pz = -(y * py) = m - (y + oy) * py
(y * py) = (y + oy) * py - m
y = y + oy - m/py
oy = m/py
same for other axes too. Applying any one offset would translate any plane into equivalency with an adjacent parallel plane


s = norm(rn × pn) <<TODO need special case for when rn and pn are colinear (or nearly so)
q = ro + s*(ro dot s)
q is ro translated along plane defined by pn such that q->rn, q->pn and o are co-planar
u = s × pn      <<TODO check handedness  also note, s and pn are normal and orthagonal so u is also normal
ql = len(q)
qn = normalize(q)
point a is ro projected onto rn from o, along the plane defined as orthagonal to pn and containing point o
sin angle aoq = len(rn × qn)
sin angle aqo = len(u × qn)
sin angle qao = len(u × rn)
rx = ql * {sin angle aqo} / {sin angle qao}
a = rx * rn
TODO maybe eliminate sqrt by combining ql * {sin angle aqo} by not normalizing q first???
Distance to the next star along rn from ro is either rx or rm-rx, depending on facing direction




distance between rn intersections of integer (ri) coordinates is calculable. (note: need to pick a margin of error to handle float precision issues)
distance (rm) between intersections between planes and the ray is therefore lcm of ri and rd; rm is known as the modulus of the pattern along normal rn (for any offset)
rm = lcm(ri, rd)   <<TODO better
